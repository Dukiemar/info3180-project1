#!/usr/bin/python
# -*- coding: utf-8 -*-
# NOTE: the shebang and encoding lines are for ScriptHeaderTests do not remove

import os
import sys
import tempfile
import shutil
from unittest import TestCase

import pkg_resources
from pkg_resources import (parse_requirements, VersionConflict, parse_version,
    Distribution, EntryPoint, Requirement, safe_version, safe_name,
    WorkingSet)

from setuptools.command.easy_install import (get_script_header, is_sh,
    nt_quote_arg)
from setuptools.compat import StringIO, iteritems

try:
    frozenset
except NameError:
    from sets import ImmutableSet as frozenset

def safe_repr(obj, short=False):
    """ copied from Python2.7"""
    try:
        result = repr(obj)
    except Exception:
        result = object.__repr__(obj)
    if not short or len(result) < pkg_resources._MAX_LENGTH:
        return result
    return result[:pkg_resources._MAX_LENGTH] + ' [truncated]...'

class Metadata(pkg_resources.EmptyProvider):
    """Mock object to return metadata as if from an on-disk distribution"""

    def __init__(self,*pairs):
        self.metadata = dict(pairs)

    def has_metadata(self,name):
        return name in self.metadata

    def get_metadata(self,name):
        return self.metadata[name]

    def get_metadata_lines(self,name):
        return pkg_resources.yield_lines(self.get_metadata(name))

dist_from_fn = pkg_resources.Distribution.from_filename

class DistroTests(TestCase):

    def testCollection(self):
        # empty path should produce no distributions
        ad = pkg_resources.Environment([], platform=None, python=None)
        self.assertEqual(list(ad), [])
        self.assertEqual(ad['FooPkg'],[])
        ad.add(dist_from_fn("FooPkg-1.3_1.egg"))
        ad.add(dist_from_fn("FooPkg-1.4-py2.4-win32.egg"))
        ad.add(dist_from_fn("FooPkg-1.2-py2.4.egg"))

        # Name is in there now
        self.assertTrue(ad['FooPkg'])
        # But only 1 package
        self.assertEqual(list(ad), ['foopkg'])

        # Distributions sort by version
        self.assertEqual(
            [dist.version for dist in ad['FooPkg']], ['1.4','1.3-1','1.2']
        )
        # Removing a distribution leaves sequence alone
        ad.remove(ad['FooPkg'][1])
        self.assertEqual(
            [dist.version for dist in ad['FooPkg']], ['1.4','1.2']
        )
        # And inserting adds them in order
        ad.add(dist_from_fn("FooPkg-1.9.egg"))
        self.assertEqual(
            [dist.version for dist in ad['FooPkg']], ['1.9','1.4','1.2']
        )

        ws = WorkingSet([])
        foo12 = dist_from_fn("FooPkg-1.2-py2.4.egg")
        foo14 = dist_from_fn("FooPkg-1.4-py2.4-win32.egg")
        req, = parse_requirements("FooPkg>=1.3")

        # Nominal case: no distros on path, should yield all applicable
        self.assertEqual(ad.best_match(req,ws).version, '1.9')
        # If a matching distro is already installed, should return only that
        ws.add(foo14)
        self.assertEqual(ad.best_match(req,ws).version, '1.4')

        # If the first matching distro is unsuitable, it's a version conflict
        ws = WorkingSet([])
        ws.add(foo12)
        ws.add(foo14)
        self.assertRaises(VersionConflict, ad.best_match, req, ws)

        # If more than one match on the path, the first one takes precedence
        ws = WorkingSet([])
        ws.add(foo14)
        ws.add(foo12)
        ws.add(foo14)
        self.assertEqual(ad.best_match(req,ws).version, '1.4')

    def checkFooPkg(self,d):
        self.assertEqual(d.project_name, "FooPkg")
        self.assertEqual(d.key, "foopkg")
        self.assertEqual(d.version, "1.3-1")
        self.assertEqual(d.py_version, "2.4")
        self.assertEqual(d.platform, "win32")
        self.assertEqual(d.parsed_version, parse_version("1.3-1"))

    def testDistroBasics(self):
        d = Distribution(
            "/some/path",
            project_name="FooPkg",version="1.3-1",py_version="2.4",platform="win32"
        )
        self.checkFooPkg(d)

        d = Distribution("/some/path")
        self.assertEqual(d.py_version, sys.version[:3])
        self.assertEqual(d.platform, None)

    def testDistroParse(self):
        d = dist_from_fn("FooPkg-1.3_1-py2.4-win32.egg")
        self.checkFooPkg(d)
        d = dist_from_fn("FooPkg-1.3_1-py2.4-win32.egg-info")
        self.checkFooPkg(d)

    def testDistroMetadata(self):
        d = Distribution(
            "/some/path", project_name="FooPkg", py_version="2.4", platform="win32",
            metadata = Metadata(
                ('PKG-INFO',"Metadata-Version: 1.0\nVersion: 1.3-1\n")
            )
        )
        self.checkFooPkg(d)

    def distRequires(self, txt):
        return Distribution("/foo", metadata=Metadata(('depends.txt', txt)))

    def checkRequires(self, dist, txt, extras=()):
        self.assertEqual(
            list(dist.requires(extras)),
            list(parse_requirements(txt))
        )

    def testDistroDependsSimple(self):
        for v in "Twisted>=1.5", "Twisted>=1.5\nZConfig>=2.0":
            self.checkRequires(self.distRequires(v), v)

    def testResolve(self):
        ad = pkg_resources.Environment([])
        ws = WorkingSet([])
        # Resolving no requirements -> nothing to install
        self.assertEqual(list(ws.resolve([],ad)), [])
        # Request something not in the collection -> DistributionNotFound
        self.assertRaises(
            pkg_resources.DistributionNotFound, ws.resolve, parse_requirements("Foo"), ad
        )
        Foo = Distribution.from_filename(
            "/foo_dir/Foo-1.2.egg",
            metadata=Metadata(('depends.txt', "[bar]\nBaz>=2.0"))
        )
        ad.add(Foo)
        ad.add(Distribution.from_filename("Foo-0.9.egg"))

        # Request thing(s) that are available -> list to activate
        for i in range(3):
            targets = list(ws.resolve(parse_requirements("Foo"), ad))
            self.assertEqual(targets, [Foo])
            list(map(ws.add,targets))
        self.assertRaises(VersionConflict, ws.resolve,
            parse_requirements("Foo==0.9"), ad)
        ws = WorkingSet([]) # reset

        # Request an extra that causes an unresolved dependency for "Baz"
        self.assertRaises(
            pkg_resources.DistributionNotFound, ws.resolve,parse_requirements("Foo[bar]"), ad
        )
        Baz = Distribution.from_filename(
            "/foo_dir/Baz-2.1.egg", metadata=Metadata(('depends.txt', "Foo"))
        )
        ad.add(Baz)

        # Activation list now includes resolved dependency
        self.assertEqual(
            list(ws.resolve(parse_requirements("Foo[bar]"), ad)), [Foo,Baz]
        )
        # Requests for conflicting versions produce VersionConflict
        self.assertRaises(VersionConflict,
            ws.resolve, parse_requirements("Foo==1.2\nFoo!=1.2"), ad)

    def testDistroDependsOptions(self):
        d = self.distRequires("""
            Twisted>=1.5
            [docgen]
            ZConfig>=2.0
            docutils>=0.3
            [fastcgi]
            fcgiapp>=0.1""")
        self.checkRequires(d,"Twisted>=1.5")
        self.checkRequires(
            d,"Twisted>=1.5 ZConfig>=2.0 docutils>=0.3".split(), ["docgen"]
        )
        self.checkRequires(
            d,"Twisted>=1.5 fcgiapp>=0.1".split(), ["fastcgi"]
        )
        self.checkRequires(
            d,"Twisted>=1.5 ZConfig>=2.0 docutils>=0.3 fcgiapp>=0.1".split(),
            ["docgen","fastcgi"]
        )
        self.checkRequires(
            d,"Twisted>=1.5 fcgiapp>=0.1 ZConfig>=2.0 docutils>=0.3".split(),
            ["fastcgi", "docgen"]
        )
        self.assertRaises(pkg_resources.UnknownExtra, d.requires, ["foo"])


class EntryPointTests(TestCase):

    def assertfields(self, ep):
        self.assertEqual(ep.name,"foo")
        self.assertEqual(ep.module_name,"setuptools.tests.test_resources")
        self.assertEqual(ep.attrs, ("EntryPointTests",))
        self.assertEqual(ep.extras, ("x",))
        self.assertTrue(ep.load() is EntryPointTests)
        self.assertEqual(
            str(ep),
            "foo = setuptools.tests.test_resources:EntryPointTests [x]"
        )

    def setUp(self):
       